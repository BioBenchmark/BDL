## Computational tools (CT entities)

The term “computational tool” refers to software tools that implement any statistical method, algorithm, or pipeline for genomic data analysis. These can be functions or packages in R, Python, or other languages; standalone command line tools; and series of commands in scripting languages or workflow languages (e.g., CWL, WDL). We exclude computational tools that require manual interactions (e.g., Graphical User Interface) and proprietary software (e.g., MATLAB).
CT entities will be designed to overcome the most troublesome steps and obstacles for performing a comprehensive benchmarking study, namely the installation and execution of computational tools that rely on different operating systems, compilers, libraries, and interpreters (9). This challenge is a very complex problem. Fortunately, the development of container technologies and tools, such as docker (62) and Singularity (63), have made it easier to encapsulate entire runtime environments of computational tools in containers and execute them on a cloud or distributed system. In addition, package distribution systems, such as conda and bioconda (64), and continuous integration systems, such as Travis CI and AppVeyor, widely use JSON- or YAML-format configuration files to specify steps for building and executing computational tools. These systems can help encapsulate the software environment for computational tools and preserve package versions and their dependencies. They have been used in some benchmarking studies (65, 66) and will be the basis of CT entities.

CT entities record recipes for the installation and execution of computational tools. They will contain 1) meta information about the computational tool, such as author and version; 2) input and output file types and applicable summarizers and converters; 3) instructions on how to build the computational tool, so it can be executed in containers; and 4) templates of scripts that apply the tool to reference datasets with different properties. Multiple entries will be allowed if the same tool can be used to perform different analyses.

Utilizing existing package management services, such as spack, conda-forge, bioconda, and Bioconductor (67), a CT entity will simply specify the “channel” and “package” of a computational tool. It is up to specific CBL executors to download and install packages from appropriate repositories, such as CRAN, Bioconductor, Python Package Index, CPAN, and GitHub. For complex cases, channels could be DockerHub and BioContainers and packages could be arbitrary user-defined docker files. Notably, all bioconda packages are available in the BioContainers project (68), so we will have base images to use.
CBL will support the use of different scripting languages (e.g., Bash, R, or Python) or workflow languages (e.g., CWL, WDL, SnakeMake, NextFlow, or SoS (54)) to specify processes for applying computational tools to reference datasets. The scripts will be specified using Jinja templates. This template language allows the use of placeholders that will be expanded with variables and supports conditions and loops to generate scripts for more complex cases. Here, variables can be any property of the CT entity and its supported DS entity and allows for an extra step to sort input variants if the input file is not sorted.
